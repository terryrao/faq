# IO 模型及封装
## IO 模型
### 阻塞和非阻塞
这个概念是针对*应用程序*而言，是指应用程序中的线程在向操作系统发送 IO 请求后，是否一直等待操作系统的 IO 响应。
如果是，那么就是阻塞式的；如果不是，那么应用程序一般会以轮询的方式以一定周期询问操作系统，直到某次获得了
IO 响应为止（轮序间隔应用程序线程可以做一些其他工作）

### 同步和异步
IO 操作都是由操作系统进行的（这里的IO操作是个广泛概念了：磁盘 IO、网络 IO 都算），不同的操作系统对不同
设备的IO 操作都有不同的模式。同步和异步这两个概念都指代的操作系统级别，同步 IO 是指<b>*操作系统和设备进行
交互时，必须等待一次完整的请求-响应完成，才能进行下一次操作*</b>（当然操作系统和设备本身也有很多技术加
快这个反应过程，例如“磁盘预读”技术、数据缓存技术）；异步IO是指操作系统和设备进行交互时，不必等待
本次得到响应，就可以直接进行下一次操作请求。设备处理完某次请求后，会主动给操作系统相应的响应通知

### 多路复用IO
多路复用IO，从*本质上看还是一种同步IO**，因为它没有100%消除 `IO_WAIT`，操作系统也没有为它提供“主动通知”机制。
但是多路复用 IO 的处理速度已经相当快了，利用设备执行 IO 操作的时间，操作系统可以继续执行 IO 请求。并同样采用
周期性轮询的方式，获取一批IO操作请求的执行响应。操作系统支持的多路复用 IO 技术主要有 select、poll、epoll、kqueue

### 阻塞式同步IO模型
这个从字面上就很好理解了，应用程序请求IO操作，并一直等待处理结果；操作系统同时也进行IO操作，并等待设备的处理结果；
可以看出，应用程序的请求线程和操作系统的内核线程都是等待状态

### 非阻塞式同步IO模型
应用程序请求IO，并且不用一直等待返回结果就去做其他事情。隔一定的周期，再去询问操作系统上次IO操作有没有结果，直到某
一次询问从操作系统拿到IO结果；操作系统内核线程在进行IO操作时，还是处理一直等待设备返回操作结果的状态。

### 非阻塞式多路复用IO模型
应用程序请求IO的工作采用非阻塞方式进行；操作系统采用多路复用模式工作

### 非阻塞式异步IO模型
应用程序请求IO的工作采用非阻塞方式进行，但是不需要轮询了，因为操作系统异步IO其中一个主要特性就是：可以在有IO响应结果的时候，主动进行通知。

## 封装
传统 java socket 套字节支持阻塞/非阻塞模式下的同步 IO （也称为 OIO 和 BIO）；java nio 在不同的操作系统下支持不同各类的多路复
用技术( windows 下的 select 模型，linux 下的 poll/epoll 模型)， java AIO 支持 异步 IO （windows 下的 IOCP 和 linux 下的 epoll
 模拟 AIO）
 
## 已知BUG
JDK-6427854 : (se) NullPointerException in Selector.open()。http://bugs.java.com/view_bug.do?bug_id=6427854

workaround the infamous epoll 100% CPU bug。http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6403933。
这个Bug出现在linux系统环境，大致是说JAVA NIO 框架在实现 Linux内核 kernel 2.6+中的epoll模型时。Selector.select(timeout)方法不能阻塞指定的timeout时间，导致CPU 100%的情况：
这个问题从官方的Bug Database中的描述看，是在JDK7的版本中被解决的。Netty框架在JDK 6+的环境下在JAVA NIO框架封装之上解决了这个Bug。
